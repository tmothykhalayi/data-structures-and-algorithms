# Common DSA Patterns

Understanding patterns helps you solve new problems faster.

---

## 1. Sliding Window
Used when dealing with arrays or strings where you need to find a contiguous subarray/substring.

**Common use cases:**
- Maximum/minimum sum subarray
- Longest substring without repeating characters
- Anagrams in a string

---

## 2. Two Pointers
Use two pointers to traverse an array or list, often from different positions.

**Common use cases:**
- Pair with target sum
- Remove duplicates
- Palindrome checking
- Reverse an array

---

## 3. Fast & Slow Pointers
Two pointers move at different speeds through a data structure.

**Common use cases:**
- Detecting cycles in linked lists
- Finding middle of linked list
- Palindrome linked list

---

## 4. Merge Intervals
Deal with overlapping intervals.

**Common use cases:**
- Merge overlapping intervals
- Insert interval
- Meeting rooms

---

## 5. Cyclic Sort
Used when dealing with arrays containing numbers in a given range.

**Common use cases:**
- Find missing number
- Find duplicates
- Find first k missing positive numbers

---

## 6. In-place Reversal of Linked List
Reverse parts or all of a linked list without using extra space.

**Common use cases:**
- Reverse linked list
- Reverse sublist
- Reverse k-element sublist

---

## 7. Tree BFS (Breadth-First Search)
Traverse a tree level by level using a queue.

**Common use cases:**
- Level order traversal
- Minimum depth
- Connect level order siblings

---

## 8. Tree DFS (Depth-First Search)
Traverse a tree using recursion or stack.

**Common use cases:**
- Sum of path numbers
- All paths for a sum
- Count paths for a sum
- Tree traversal (pre-order, in-order, post-order)

---

## 9. Binary Search
Search in a sorted array by repeatedly dividing the search space.

**Common use cases:**
- Search in sorted array
- Find peak element
- Search in rotated array

---

## 10. Top K Elements
Find top/smallest/most frequent k elements using heap.

**Common use cases:**
- K largest elements
- K closest points
- Top k frequent numbers

---

## 11. Divide and Conquer
Break problem into smaller subproblems, solve independently, and combine results.

**Example Algorithms:**
- Merge Sort
- Quick Sort
- Binary Search

---

## 12. Dynamic Programming
Break down problems into smaller subproblems and store results to avoid recomputation.

**Key Properties:**
- Optimal substructure
- Overlapping subproblems

**Common patterns:**
- 0/1 Knapsack
- Unbounded Knapsack
- Fibonacci numbers
- Longest Common Subsequence
- Longest Increasing Subsequence
- Edit Distance

---

## 13. Greedy
Make the locally optimal choice at each step with the hope of finding a global optimum.

**Common use cases:**
- Coin change
- Activity selection
- Minimum spanning tree
- Set operations (union, intersection, difference)

---

## 14. Backtracking
Build solutions incrementally and abandon them if they don't satisfy constraints.

**Common use cases:**
- Subsets
- Permutations
- Combination sum
- N-Queens

---

## 15. Recursion
Function calls itself to solve smaller instances of the same problem.

**Common uses:**
- Tree traversal
- Factorial calculation
- Fibonacci sequence
- Divide and conquer algorithms

